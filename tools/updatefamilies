#!/usr/bin/python3

import argparse, os, json
from functools import lru_cache
from subprocess import check_output

baseurl = "https://github.com/silnrsi/fonts/raw/main/fonts"

def build(fmdat, currdat, k):
    return build_v02(fmdat, currdat, k)

def build_v02(fmdat, v, k):
    hosturl = baseurl
    if fmdat is None:
        fmdat = v.get('files', {})
        hosturl = None
    elif 'status' not in v:
        v['status'] = 'current'
    if 'fontfamilyId' in v:
        ffid = v['fontFamilyId']
        del v['fontFamilyId']
        v['familyid'] = ffid
    else:
        v['familyid'] = k
    filesroot = ""
    if 'filesroot' in v:
        filesroot = v['filesroot']
        del v['filesroot']
    flourl = None
    if 'hosturl' in v:
        hosturl = v['hosturl']
        del v['hosturl']
    elif hosturl == baseurl:
        flourl = os.path.join('https://fonts.languagetechnology.org/fonts', filesroot).rstrip("/")
    family = None
    files = {}
    tracking = {}
    for f, d in fmdat.items():
        if 'family' in d:
            family = d['family']
            del d['family']
        newk = os.path.basename(f)
        tracking.setdefault(os.path.splitext(newk)[1], []).append(newk)
        curr = {}
        files[newk] = curr
        curr['fontpath'] = f if filesroot == "" else os.path.join(filesroot, f)
        if flourl is not None:
            curr['flourl'] = os.path.join(flourl, filesroot, f)
        if hosturl is not None:
            curr['url'] = os.path.join(hosturl, filesroot, f)
        curr.update(d)
    v['files'] = files
    for e, l in tracking.items():
        key = "default{}".format(e[1:])
        if key not in v and len(l) == 1:
            v[key] = l[0]
    if 'family' not in v and family is not None:
        v['family'] = family
    v['downloadmethod'] = 'default'
    if hosturl is None:
        v['downloadmethod'] = 'none' if 'package' not in v else 'package'
    # Ensure version fields are floats
    for a in ('version', 'googlefonts/version'):
        b = a.split("/")
        curr = v
        for ck in b[:-1]:
            if ck not in curr:
                break
            curr = curr[ck]
        else:
            val = curr[b[-1]]
            try:
                curr[b[-1]] = float(val)
            except ValueError:
                print('Could not convert {}: "{}" to a float in {}'.format(a, val, k))
    # can't have top level altfamily and files fields together
    if 'altfamily' in v and 'files' in v:
        print("Files mismatched in {}. Unexpected family level altfamily encountered".format(k))
    return v

@lru_cache()
def getcurrsha():
    res = check_output(["git", "log", "-1", "--pretty=format:%h"]).decode('utf-8')
    return res.strip()

def prettydict(data, indent, ink, oneline=False, oneliners=None):
    res = ["{"]
    thisoneline = oneline and (oneliners is None or ink not in oneliners)
    for k, v in sorted(data.items()):
        line = ("" if thisoneline else indent) + '"{}": '.format(k)
        if isinstance(v, dict):
            val = prettydict(v, indent+"    ", k, oneline=(oneline if oneliners is None or k not in oneliners else True), oneliners=oneliners)
        else:
            val = json.dumps(v, ensure_ascii=False)
        res.append(line + val + ",")
    res[-1] = res[-1][:-1]
    res.append(("" if thisoneline else indent[:-4]) + "}")
    return (" " if thisoneline else "\n").join(res)
        
def prettyout(data, outf):
    outf.write(prettydict(data, "", None, oneliners=["files"]))

parser = argparse.ArgumentParser()
parser.add_argument("infile",help="basis families.json")
parser.add_argument("outfile",help="families.json to output")
parser.add_argument("-i","--indir",help="Root of input directory tree to process")
parser.add_argument("-d","--dir",action="append",default=[],help="Single directory to process (can be repeated) relative to indir")
args = parser.parse_args()

inoutdir = os.path.dirname(args.infile)
dirs = []
if not len(args.dir) and args.indir is not None:
    for dp, dn, fn in os.walk(args.indir):
        for a in ('font', ''):
            f = a + 'manifest.json'
            if f in fn:
                dirs.append((dp, f))

with open(args.infile) as inf:
    data = json.load(inf)

results = {}
for d, f in dirs:
    fmpath = os.path.join(d, f)
    fid = os.path.split(d)[-1].lower().replace(" ", "")
    with open(fmpath, encoding="utf-8") as inf:
        fmdat = json.load(inf)
    if 'files' in fmdat:    # old style fontmanifest
        fmdat = {fid: fmdat}
    for k, v in fmdat.items():
        if k not in data:
            print(f"Entry for {k} missing. It's probably new")
            data[k] = {}
        results[k] = build(v['files'], data[k], k)
for k, v in data.items():
    if k in results:
        continue
    results[k] = build(None, data[k], k)

with open(args.outfile, "w", encoding="utf-8") as outf:
    prettyout(results, outf)
