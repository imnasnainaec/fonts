#!/usr/bin/python3

import argparse, os, json
from functools import lru_cache
from subprocess import check_output

def normalize(families):
    for k, v in families.items():
        family = None
        if 'filesroot' in v:
            v['filesroot'] = v['filesroot'].rstrip('/')
        # Remove family field from manifest information
        for f, d in v.get('files', {}).items():
            if 'family' in d:
                family = d['family']
                del d['family']
        if 'family' not in v and family is not None:
            v['family'] = family
        # Ensure version fields are floats
        for a in ('version', 'googlefonts/version'):
            b = a.split("/")
            curr = v
            for ck in b[:-1]:
                if ck not in curr:
                    break
                curr = curr[ck]
            else:
                val = curr[b[-1]]
                try:
                    curr[b[-1]] = float(val)
                except ValueError:
                    print('Could not convert {}: "{}" to a float in {}'.format(a, val, k))
        # can't have top level altfamily and files fields together
        if 'altfamily' in v and 'files' in v:
            print("Files mismatched in {}. Unexpected family level altfamily encountered".format(k))
    return families

@lru_cache()
def getcurrsha():
    res = check_output(["git", "log", "-1", "--pretty=format:%h"]).decode('utf-8')
    return res.strip()

def prettydict(data, indent, ink, oneline=False, oneliners=None):
    res = ["{"]
    thisoneline = oneline and (oneliners is None or ink not in oneliners)
    for k, v in sorted(data.items()):
        line = ("" if thisoneline else indent) + '"{}": '.format(k)
        if isinstance(v, dict):
            val = prettydict(v, indent+"    ", k, oneline=(oneline if oneliners is None or k not in oneliners else True), oneliners=oneliners)
        else:
            val = json.dumps(v, ensure_ascii=False)
        res.append(line + val + ",")
    res[-1] = res[-1][:-1]
    res.append(("" if thisoneline else indent[:-4]) + "}")
    return (" " if thisoneline else "\n").join(res)
        
def prettyout(data, outf):
    outf.write(prettydict(data, "", None, oneliners=["files"]))

parser = argparse.ArgumentParser()
parser.add_argument("inoutfile",help="families,json file to update")
parser.add_argument("-i","--indir",help="Root of input directory tree to process")
parser.add_argument("-d","--dir",action="append",default=[],help="Single directory to process (can be repeated) relative to indir")
parser.add_argument("-S","--addshas",action="store_true",help="Add versioning sha information")
args = parser.parse_args()

inoutdir = os.path.dirname(args.inoutfile)
dirs = []
if not len(args.dir) and args.indir is not None:
    for dp, dn, fn in os.walk(args.indir):
        for a in ('font', ''):
            f = a + 'manifest.json'
            if f in fn:
                dirs.append((dp, f))

with open(args.inoutfile) as inf:
    data = json.load(inf)

for d, f in dirs:
    fmpath = os.path.join(d, f)
    fid = os.path.split(d)[-1].lower().replace(" ", "")
    with open(fmpath, encoding="utf-8") as inf:
        fmdat = json.load(inf)
    if 'files' in fmdat:    # old style fontmanifest
        fmdat = {fid: fmdat}
    for k, v in fmdat.items():
        if k not in data:
            print(f"Entry for {k} missing. It's probably new")
            data[k] = {}
        currdat = data[k]
        if args.addshas:
            currver = currdat.get('version', None)
            newver = fmdat.get('version', None)
            currsha = currdat.get("sha", None)
            if currver != newver:
                if currsha is not None:
                    currdat.setdefault('versions', {})[currver] = currsha
            if currsha is None:
                fmdat['sha'] = getcurrsha()
        currdat.update(v)

data = normalize(data)

with open(args.inoutfile, "w", encoding="utf-8") as outf:
    prettyout(data, outf)
